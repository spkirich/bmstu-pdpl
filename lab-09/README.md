# Математический сопроцессор

Изучить скорость выполнения операций над числами с плавающей запятой на
примере сложения и умножения `float`, `double` и `long double`. Как с
генерацией компилятором команд сопроцессора, так и с явным их использованием.

Сравнить точность вычислений `sin(π / 1)` и `sin(π / 2)` для приближённых
значений `3.14`, `3.141596` и значения, загружаемого командой сопроцессора.

## Замечания

Здесь чудеса, на которые способны параметры ассемблерной вставки GCC,
становятся особенно чудесными. Присмотримся к такому коду:

```c
asm("faddp" : "=t" (*c) : "u" (*a), "0" (*b) : "st(1)");
```

Видим новые буквы: `t` и `u` обозначают вершину стека сопроцессора и
следующий за ней элемент соответственно, то есть регистры `st(0)` и `st(1)`.
`0` же говорит о том, что значение `*b` мы кладём туда же, откуда потом берём
первый параметр, то есть на вершину стека.

Укажем также `st(1)` неявно изменяемым, поскольку из-за выталкивания его
содержимое действительно изменяется, но компилятор об этом не знает - для
него через этот регистр передаётся входной параметр.

Как видим, огромное количество предварительных действий лаконично выражается
с помощью параметров вставки, так что в качестве её содержимого остаётся
только сама команда сложения с выталкиванием.
